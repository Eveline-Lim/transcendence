syntax = "proto3";

package ai_opponent;


// AI Opponent Service - provides computer-controlled opponents
service AIOpponentService {
  // Get next AI move based on current game state
  rpc GetMove(GameState) returns (AIMove);

  // Stream moves for real-time gameplay
  rpc StreamMoves(stream GameState) returns (stream AIMove);
  
  // Submit match result for pattern learning
  rpc AnalyzeMatch(MatchAnalysisRequest) returns (MatchAnalysisResponse);
}

// Difficulty levels for AI
enum Difficulty {
  DIFFICULTY_UNSPECIFIED = 0;
  DIFFICULTY_EASY = 1;
  DIFFICULTY_MEDIUM = 2;
  DIFFICULTY_HARD = 3;
  DIFFICULTY_IMPOSSIBLE = 4;
}

// Game arena dimensions
message ArenaBounds {
  float width = 1;
  float height = 2;
}

// Current state of the game
message GameState {
  string game_id = 1;
  Difficulty difficulty = 2;
  BallState ball = 3;
  PaddleState ai_paddle = 4;
  PaddleState player_paddle = 5;
  ArenaBounds arena = 6;
  int32 ai_score = 7;
  int32 player_score = 8;
  repeated PowerUp power_ups = 9;
  GameConfig config = 10;
}

message BallState {
  float x = 1;
  float y = 2;
  float velocity_x = 3;
  float velocity_y = 4;
}

message PaddleState {
  float y = 1;
  float height = 2;
  float speed = 3;
}

message PowerUp {
  string type = 1; // SPEED_BOOST, PADDLE_ENLARGE, etc.
  float x = 2;
  float y = 3;
}

message GameConfig {
  bool power_ups_enabled = 1;
  float paddle_speed_multiplier = 2;
  float ball_speed_multiplier = 3;
}

message MatchAnalysisRequest {
  string match_id = 1;
  string player_id = 2;
  repeated GameState history = 3;
  string result = 4; // WIN, LOSS
}

message MatchAnalysisResponse {
  bool success = 1;
  float learning_rate_applied = 2;
}

// AI's response - where to move the paddle
message AIMove {
  float target_y = 1;
  optional float reaction_delay_ms = 2; // Simulated reaction time (may be omitted)
}